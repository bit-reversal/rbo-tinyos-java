\documentclass{letter}
\usepackage{amsmath,amssymb,graphicx}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\section}[1]{\medskip\bigskip

\noindent\textbf{\LARGE #1}}
\newcommand{\subsection}[1]{\medskip\bigskip

\noindent\textbf{\Large #1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newenvironment{proof}{\noindent\textbf{Proof\ }}{\hspace*{\fill}$\Box$\medskip}
\newtheorem{theorem}{Theorem}
%%%%%%%%%% End TeXmacs macros

\begin{document}

\title{\title{RBO protocol}\author{Marcin Kik}\maketitle}\author{}\maketitle

\includegraphics{rbo-seminar-1.eps}

\section{The basic ideas}

\subsection{Binary search ordering}

Binary search ordering permutation and the underlying binary tree:

\includegraphics{rbo-seminar-2.eps}

Functions for computing $\tmop{bs}_k$ and $\tmop{bs}_k^{- 1}$:
\begin{itemize}
  \item index of rightmost one \ ($\tmop{irmo}_k$):
  \begin{itemize}
    \item for $x > 0$, \ $\tmop{irmo}_k (x) = \min \{j \geq 0| \lfloor x / 2^j
    \rfloor \tmop{mod} 2 = 1\}$
    
    \item $\tmop{irmo}_k (0) = k$
  \end{itemize}
  \item level of $x$ in the three of $\tmop{bs}_k$ \ ($\tmop{lbs}_k$), for $0
  \leqslant x \leqslant 2^k - 1$ :
  \begin{itemize}
    \item $\tmop{lbs}_k (x) = k - \tmop{irmo}_k (x)$
    \begin{itemize}
      \item $(0, \tmop{bs}_k (0))$ is the root on level $0$
      
      \item $(2^{k - 1}, \tmop{bs}_k (2^{k - 1}))$ is the (only) node on level
      $1$ -- the root for $x > 0$.
      
      \item level $l > 0$ consists of nodes with $x \in \{2^{k - l} + 2^{k - l
      + 1} \cdot m | 0 \leqslant m < 2^{l - 1} \}$
    \end{itemize}
  \end{itemize}
  \item permutation $\tmop{bs}_k$, for $0 \leqslant x \leqslant 2^k - 1$ :
  \begin{itemize}
    \item $\tmop{bs}_k (x) = \lfloor 2^{\tmop{lbs}_k (x) - 1} \rfloor +
    \lfloor x / 2^{\tmop{irmo}_k (x) + 1} \rfloor$
    \begin{itemize}
      \item number of nodes above $x$ : \ $\lfloor 2^{\tmop{lbs}_k (x) - 1}
      \rfloor$
      
      \item position of $x$ within its level: $\lfloor x / 2^{\tmop{irmo}_k
      (x) + 1} \rfloor$
      
      \item $\tmop{bs}_k (0) = \lfloor 2^{- 1} \rfloor + \lfloor 0 / 2^{k + 1}
      \rfloor = 0$
    \end{itemize}
    \item Other way:
    \begin{itemize}
      \item $\tmop{bs}_k (0) = 0$
      
      \item for $x > 0$ : $\tmop{bs}_k (x) = 2^{\tmop{lbs}_k (x) - 1} + (x -
      2^{\tmop{irmo}_k (x)}) / 2^{\tmop{irmo}_k (x) + 1}$
    \end{itemize}
    \item Recursion (since odd $x$-values are on the last level):
    \begin{eqnarray*}
      \tmop{bs}_0 (x) & = & 0\\
      \tmop{bs}_{k + 1} (x) & = & \tmop{bs}_k (\lfloor x / 2 \rfloor) + (x
      \tmop{mod} 2) \cdot (2^k + \lfloor x / 2 \rfloor)
    \end{eqnarray*}
  \end{itemize}
  \item level of $y$ in the tree ($\tmop{lv} (y)$):
  \begin{itemize}
    \item $\tmop{lv} (y) = \lceil \lg (y + 1) \rceil$
    \begin{itemize}
      \item $y$-values in levels: $\{0\}$, $\{1\}$, $\{2, 3\}$, $\{4, 5, 6,
      7\}$, $\ldots$
      
      \item $l = \tmop{lv} (y)$ \ iff \ $2^{l - 1} < y + 1 \leqslant 2^l$ 
    \end{itemize}
  \end{itemize}
  \item permutation reverse to $\tmop{bs}_k$ \ ($\tmop{bs}_k^{- 1}$), for $0
  \leqslant y \leqslant 2^k - 1$ :
  \begin{itemize}
    \item $\tmop{bs}_k^{- 1} (y) = (y - 2^{\tmop{lv} (y) - 1}) \cdot 2^{k -
    \tmop{lv} (y) + 1} + 2^{k - \tmop{lv} (y)}$
    \begin{itemize}
      \item for $y = 0$ : $(0 - 2^{- 1}) \cdot 2^{k + 1} + 2^k = - 2^k + 2^k =
      0$
      
      \item for $y > 0$ : $\tmop{xstep}_{\tmop{lv} (y)} = 2^{k - \tmop{lv} (y)
      + 1}$, \ $\tmop{xfirst}_{\tmop{lv} (y)} = 2^{k - \tmop{lv} (y)}$, and
      
      the node $(\tmop{bs}_k^{- 1} (y), y)$ is on position $(y - 2^{\tmop{lv}
      (y) - 1})$ within its level
      
      (There are $2^{\tmop{lv} (y) - 1}$ nodes above the level $\tmop{lv}
      (y)$.) 
    \end{itemize}
  \end{itemize}
\end{itemize}


\subsection{Recursive binary search ordering}

We can permute the nodes withing each level:

\includegraphics{rbo-seminar-3.eps}

\includegraphics{rbo-seminar-4.eps}

\includegraphics{rbo-seminar-5.eps}



Algorithm for computing $\tmop{rbs}_k (x)$, for $0 \leqslant x \leqslant 2^k -
1$ :
\begin{verbatim}
function 
  if  then return ;
  ;
  ;
  return ;
\end{verbatim}
Algorithm for computing $\tmop{rbs}_k^{- 1} (y)$, for $0 \leqslant y \leqslant
2^k - 1$ :
\begin{verbatim}
function 
  if  then return ;
  ;
  return ;
\end{verbatim}
\includegraphics{rbo-seminar-6.eps}



Recursion (since odd $x$-values are on the last level):
\begin{eqnarray*}
  \tmop{rbs}_0 (x) & = & 0\\
  \tmop{rbs}_{k + 1} (x) & = & \tmop{rbs}_k (\lfloor x / 2 \rfloor) + (x
  \tmop{mod} 2) \cdot 2^k
\end{eqnarray*}


Bit reverse permutation:
\begin{itemize}
  \item for $0 \leqslant x < 2^k$: \ \ $\tmop{rbits}_k (x) = \sum_{i = 0}^{k -
  1} 2^i \cdot x_{k - 1 - i}$, where $x_i = (x / 2^i) \tmop{mod} 2$.
\end{itemize}
\begin{theorem}
  $\tmop{rbs}_k = \tmop{rbs}_k^{- 1} = \tmop{rbits}_k$.
\end{theorem}

\begin{proof}
  By unfolding the recursion on $\tmop{rbs}_k$.
\end{proof}

\includegraphics{rbo-seminar-7.eps}

\includegraphics{rbo-seminar-8.eps}

\includegraphics{rbo-seminar-9.eps}



\section{Implementation Notes}

\subsection{Basic functions (module Rbo)}

Reversing bits:
\begin{verbatim}
    public static int revBits(int k, int x) // reverse of k lowest bits
    {
        int y= (x&1);
        for(int i=1; i<k; i++)
            {
                y= y<<1;
                x= x>>1;
                y= (y | (x&1));
            }
        return y;
    }
\end{verbatim}
Shift on the level of $x$:
\begin{verbatim}
    public static int shift(int k, int x) 
    // shift on the level of x (and step on the next level)
    {
        int mask = (1<<k)-1;
        while( (x&mask) != 0 ) mask = mask >> 1;
        return mask^(mask>>1);
    }

\end{verbatim}
Level of $y$:
\begin{verbatim}
    public static int lv(int y)  // level of y-value y in the tree of bs_k
    {
        int l=0;
        while(y!=0) 
            {
                y=(y>>1);
                l++;
            }
        return l;
    }
\end{verbatim}
Minimal $y$ in the $\tmop{revBits} ([r_1, r_2])$:
\begin{verbatim}
    public static int minRevBits(int k, int r1, int r2)
    // min(revBits([r1,r2])) // we assume: 0<=r1<=r2< 2^k
    {
        int x=0; // root
        int s=shift(k, x);
        while(x<r1 || r2<x)
            {
                if(x<r1)
                    // x=x+shift(k, x);
                    x=x+s;
                else
                    // x=x-shift(k, x);
                    x=x-s;
                s=s>>1;
            }
        return revBits(k, x);
    }
\end{verbatim}
Maximal \ $y$ in the $\tmop{revBits} ([r_1, r_2])$:
\begin{verbatim}
    public static int maxRevBits(int k, int r1, int r2)
    // max(revBits([r1,r2])) // we assume: 0<=r1<=r2< 2^k
    {
        int mask= (1<<k)-1;
        return mask ^ minRevBits(k, r2^ mask, r1^mask );
    }
\end{verbatim}


First time slot $y$ after $t$ (modulo $2^k$), such that $\tmop{revBits} (y
\tmop{mod} 2^k) \in [r_1, r_2]$:
\begin{verbatim}
    public static int naiveNextSlotIn(int k, int t, int r1, int r2)
    // (t+min{d>0 : r1<= revBits( (t+d)mod 2^k   ) <=r2}) mod 2^k 
    // we assume 0<=r1<=r2< 2^k 
    {
        int mask=(1<<k)-1; // 2^k-1 
        t=((t+1) & mask);  // (t+1) mod 2^k
        int r=revBits(k, t);
        while(r<r1 || r2<r)
            {
                t=((t+1) & mask);
                r=revBits(k, t);
            }
        return t;
    }
\end{verbatim}
\begin{verbatim}
    public static int reverseNextSlotIn(int k, int t, int r1, int r2)
    // (t+min{d>0 : r1<= revBits( (t+d)mod 2^k   ) <=r2}) mod 2^k 
    // we assume 0<=r1<=r2< 2^k 
    {
        int n=(1<<k);
        int t1=revBits(k, r1);
        int globalMin=t1;
        int minAfter=(t1>t)? t1: n;
        for(int r=r1+1; r<=r2; r++)
            {
                t1=revBits(k, r);
                if(t1<globalMin) globalMin=t1;
                if(t1>t && t1<minAfter) minAfter=t1;
            }
        if(minAfter<n) return minAfter;
        else return globalMin; 
    }
\end{verbatim}

\begin{verbatim}
    public static int plogNextSlotIn(int k, int t, int r1, int r2)
    // (t+min{d>0 : r1<= revBits( (t+d)mod 2^k   ) <=r2}) mod 2^k 
    // we assume 0<=r1<=r2< 2^k // iterative version
    {
        int rec=0;
        int tFirst, tLast, l, minL, maxL, aboveL, tFirstL, tLastL;
        int shift, stepmask;
        while(true)
            {
                if(r1<r2) // test if r1 or r2 can be removed
                    {
                        int r=revBits(k, t);
                        if(r==r1) r1++;  // possible reduction to singleton
                        else if(r==r2) r2--; // possible reduction to singleton
                    }
                if(r1==r2) // [r1,r2] is a singleton -  no choice
                   return rec+revBits(k,r1); 

                tFirst=minRevBits(k, r1,r2); // first slot in [r1,r2]

                if(t < tFirst)  // we are before entrace to [r1,r2] in this round
                  return rec+(tFirst);

                tLast= maxRevBits(k, r1,r2); // last slot in [r1,r2]

                if(tLast <= t) 
                  // wait till the entrance to [r1,r2] in the next round 
                  return rec+(tFirst); 

                // here: t<tLast

                // find min{ l>= lv(t): level l intersects [r1,r2] } 
                // (It must exist since: t<= tLast) 
                l=lv(t); // level of t
                shift=(1<<(k-l));
                stepmask= ~((shift<<1)-1);
                minL=((r1+shift-1)&stepmask)+shift;
                maxL=((r2-shift)&stepmask)+shift;
                while(minL>maxL) // [r1,r2] does not intersect level l
                    {
                        l++;
                        shift=shift>>1;
                        stepmask=stepmask>>1;
                        minL=((r1+shift-1)&stepmask)+shift;
                        maxL=((r2-shift)&stepmask)+shift;
                    }
                // [minL, maxL] is minimal interval that contains 
                // the intersection of level l with [r1,r2] 
                minL= minL>>(k-l+1);
                maxL= maxL>>(k-l+1);
                // [minL, maxL] are now the coresponding nodes 
                // in the tree formed from level l

                // find the first in [r1,r2] within the tree made of level l: 
                tFirstL=minRevBits(l-1, minL, maxL); 
 
                aboveL= 1<<(l-1); // number of nodes above level l
                if(t< aboveL+tFirstL)
                    {   // next hitting slot is the first within the level l
                        return rec+ aboveL+tFirstL; 
                    }

                // here: l=lv(t) and t>= aboveL+tFirstL

                // find the last in [r1,r2] within the tree made of level l: 
                tLastL=maxRevBits(l-1, minL,maxL); 

                if(t>= aboveL+tLastL)
                    {
                        // here: l=lv(t) and t>=aboveL+tLastL 
                        // and l<k (since t<maxRevBits(k, r1,r2))

                        // next hitting slot after t is the first one within 
                        // some  level after lv(t)

                        l++;
                        shift=shift>>1;
                        stepmask=stepmask>>1;
                        minL=((r1+shift-1)&stepmask)+shift;
                        maxL=((r2-shift)&stepmask)+shift;

                        while(minL>maxL)
                            {
                                l++;
                                shift=shift>>1;
                                stepmask=stepmask>>1;
                                minL=((r1+shift-1)&stepmask)+shift;
                                maxL=((r2-shift)&stepmask)+shift;
                            }

                        minL= minL>>(k-l+1);
                        maxL= maxL>>(k-l+1);

                        aboveL= (1<< l-1);
                        return rec+ aboveL+minRevBits(l-1, minL, maxL);
                    }
        
                // next slot after t is within level l=lv(t)
 
                // RECURSION !

                rec=rec+aboveL; 
                  // rec - accumulated from the previous levels of recursion

                // new values of the parameters:
                k=l-1;
                t=t-aboveL;
                r1=minL;
                r2=maxL;
            }
    }
\end{verbatim}

\begin{verbatim}
    public static int nextSlotIn(int k, int t, int r1, int r2)
    // (t+min{d>0 : r1<= revBits( (t+d)mod 2^k   ) <=r2}) mod 2^k 
    // we assume 0<=r1<=r2< 2^k 
    {
        if(r1==r2) return revBits(k,r1);
        int length=r2-r1;
        int lengthReverse= (1<<k)/length;
        if(length<150 || lengthReverse<150)
            if(lengthReverse<=length-20)
                return naiveNextSlotIn(k,t,r1,r2);
            else
                return reverseNextSlotIn(k,t,r1,r2);
        else
            return plogNextSlotIn(k,t,r1,r2);
    }
\end{verbatim}


\subsection{Protocol message header (RboHeader)}

Fields in the header of the rbo message:
\begin{verbatim}
public class RboHeader extends Rbo {

    byte sequenceId;
        // if sequence of keys changes it should be changed. 
        // Zero is reserved for invalid Id - should not be used 

    byte logSequenceLength; 
       // logarithm to the base of 2 of the sequence length. 
       // The length of the sequence is integer power of two.

    short timeSlotLength;   
      // interval between consecutive transmissions - in milliseconds

    int key;  // key of the message

    int rank; 
       // rank of the key in the sequence. 
       // Transmitted in the slot  revBits(logSequenceLength, rank)

\end{verbatim}

\subsection{Protocol (RboProtocol)}

General protocol variables:
\begin{verbatim}
public class RboProtocol extends Rbo{

    static final byte INVALID_ID=0;

    byte sequenceId=INVALID_ID;
    byte logSequenceLength; // not valid if sequenceId==0
    short timeSlotLength;   // not valid if sequenceId==0


\end{verbatim}

\subsection{Receiver protocol (RboReceiver)}

Receiver part of the protocol. (Extends RboProtocol.)

Protocol variables:
\begin{verbatim}
    // byte sequenceId;  // in RboProtocol
    // byte logSequenceLength; // in RboProtocol

    volatile int searchedKey; 
       // the key to be found in the transmitted sequence

    volatile int minRank; 
      // lower bound for the rank of the searchedKey. 
      // Not valid if getSequenceId()==0
    volatile int maxRank; 
      // upper bound for the rank of the searchedKey. 
      // Not valid if getSequenceId()==0

    volatile byte state=IDLE;    
       // state of the RboReceiver. Initially IDLE

    volatile RboMessage lastReceived = new RboMessage(); 
       // buffer for the last received message

    volatile byte lastError=SUCCESS;

    // parameters for fine-tunig:
 
    int timeout =DEFAULT_TIMEOUT; 
      // timeout for listening in ms

    int timeMargin =DEFAULT_TIME_MARGIN; 
      // time margin in ms

    int minSleepingTime =DEFAULT_MIN_SLEEPING_TIME; 
      // minimal sleeping time in ms

    int logMargin=DEFAULT_LOG_MARGIN; 
      // logarithm of the time margin
\end{verbatim}


State constants:
\begin{verbatim}
    // state constants. In TinyOS use rather "enum"
    public static final byte IDLE=0;
    public static final byte LISTENING=1;
    public static final byte SLEEPING=2;
\end{verbatim}
Error constants:
\begin{verbatim}
    // error constans.  In TinyOS use rather "enum" combined with error_t
    public static final byte SUCCESS=0;   
      // the message with searchedKey has been found
    public static final byte TIMEOUT=1; 
      // nothing received in LISTENING state
    public static final byte KEY_NOT_PRESENT=2; 
      // the seachedKey is not present in the sequence
    public static final byte BAD_MESSAGE=3; 
      // bad message received
    public static final byte FAILED_RADIO=4; 
      // switching the radio on/off failed
\end{verbatim}
Default parameters:
\begin{verbatim}
    // default values of parameters
    public static final int DEFAULT_TIMEOUT= (1<<13); // 8192 ms
    public static final int DEFAULT_TIME_MARGIN=4; // ms
    public static final int DEFAULT_MIN_SLEEPING_TIME= (1<<6); // 64 ms
    public static final int DEFAULT_LOG_MARGIN= 7; 
\end{verbatim}
Implementation of the timers' events:
\begin{verbatim}
    class TimeoutTimerEvents implements TinyTimerEvents{
        public void fired()
        {
            if(state==LISTENING)
                {
                    switchToIdle();
                    postSearchDoneTask(lastReceived, TIMEOUT); 
                    // search failed due to timeout
                }
        }
    };
\end{verbatim}
\begin{verbatim}
    class SleepingTimerEvents implements TinyTimerEvents{
        public void fired()
        {
            if(state==SLEEPING)
                {
                    switchToListening();
                }
        }
    };
\end{verbatim}
Implementation of the receive event:
\begin{verbatim}
    class ReceiveEvents implements TinyReceiveEvents{
        public RboMessage receive(RboMessage message)
        {
            if(state==LISTENING)
                {
                    timeoutTimer.stop(); 
                    // processing of the message

                    {
                        // swap buffers 
                        RboMessage tmp=lastReceived;
                        lastReceived=message;
                        message=tmp;
                        // now the recent message is in lastReceived
                    }

                    {
                        // check for vaildity
                        if(lastReceived.header.getSequenceId()==INVALID_ID)
                            {
                                // break searching
                                switchToIdle();
                                postSearchDoneTask(lastReceived, BAD_MESSAGE); 
                                  // search failed due to bad message
                                return message; 
                                  // return buffer to the receive module
                            }
                    }

                    {
                        // check whether the sequence has changed
                        if((lastReceived.header.getSequenceId()!= sequenceId) || 
                           (lastReceived.header.getLogSequenceLength()!=
                              logSequenceLength))
                            {
                                // forget the previous parameters and results
                                sequenceId=lastReceived.header.getSequenceId();
                                logSequenceLength=
                                  lastReceived.header.getLogSequenceLength();
                                minRank=0;
                                maxRank=(1<<logSequenceLength)-1;
                            }
                    }

                    {
                        // check for success and/or update 
                        // the bounds: [minRank, maxRank]
                        if(lastReceived.header.getKey()==searchedKey)
                            {
                                // we have found one of the instances of the key
                                switchToIdle();
                                postSearchDoneTask(lastReceived, SUCCESS); 
                                  // report SUCCESS
                                return message; 
                                 // return buffer to the receive module
                            }

                        // here: lastReceived.header.getKey()!=searchedKey
                        // we may update either minRank or maxRank
                        if((lastReceived.header.getKey()>searchedKey) && 
                           (lastReceived.header.getRank()<= maxRank) 
                           )
                            maxRank=lastReceived.header.getRank()-1; 
                              // update maxRank
                        else if((lastReceived.header.getKey()<searchedKey) &&
                                (lastReceived.header.getRank()>= minRank) 
                                )
                            minRank=lastReceived.header.getRank()+1; 
                              // update minRank
                                
                        // now we may notice the absence 
                        // of searchedKey in the sequence
                        if(minRank>maxRank)
                            {
                                // the searchedKey is not present 
                                // in the transmitted sequence
                                switchToIdle();
                                postSearchDoneTask(lastReceived,KEY_NOT_PRESENT);                                 // report the absence of the key
                                return message; 
                                  // return buffer to the receive module
                            }
                    }

                    {
                        // compute the time to the next useful message 
                        // and decide whether to sleep
                        int now= revBits(logSequenceLength,
                                         lastReceived.header.getRank());
                           // time slot for the lastReceived message
                        int next= nextSlotIn(logSequenceLength, now, 
                                             minRank, maxRank);
                        int slotsToNext;
                        if(now<next)
                            slotsToNext=next-now;
                        else
                            slotsToNext=((1<<logSequenceLength)-now)+next;

                        int remainingTime=
                           slotsToNext*lastReceived.header.getTimeSlotLength();

                        // now see if you can sleep
                        
                        if(remainingTime>=minSleepingTime)
                            switchToSleeping(
                                              remainingTime 
                                              - (remainingTime>>logMargin)
                                              - timeMargin 
                                             );
                                // not too short, not too long
                        else
                            switchToListening(); // restart timeout
                    }
                }
            return message; // return buffer to the receive module
        }
    } 
\end{verbatim}
Starting searching:
\begin{verbatim}
    public void search(int key) 
    // start searching for the new key. 
    // old results can be used
    {

        if(sequenceId!=INVALID_ID) 
           // we may use old results; 
           //we hope that any actual change of the sequence will be noticed
           if(key<searchedKey)
                minRank=0; 
                   // old lower bound on rank is invalid
           else if(key>searchedKey)
                maxRank=(1<<logSequenceLength)-1; 
                   // old upper bound on rank is invalid
        // else key==searchedKey -- just continue
        searchedKey=key; // set the new key to be searched
        switchToListening(); // restarts timeout timer
    }
\end{verbatim}
Posting event with results:


\begin{verbatim}
    void postSearchDoneTask(final RboMessage message, final byte error)
    {
        lastReceived=null;
        TinyTask task=new TinyTask(){
                public void run()
                {
                    lastError=error;
                    lastReceived=events.searchDone(message, error);
                }
            };
        // ... post to the queue
        tinyTaskQueue.enqueue(task);
    }
\end{verbatim}

\end{document}
